#define _CRT_SECURE_NO_WARNINGS 1 

//操作符(运算符)
//操作符分类：
//算术操作符 + - * / %
// / --- 两边操作数都是整数,执行整数除法,如果想计算小数,除号两端至少有一个是小数
// % --- 计算整除之后的余数,两端操作数只能是整数
//#include<stdio.h>
//
//int main()
//{
//	int ret1 = 10 / 3;
//	double ret2 = 10.0 / 3;
//	int ret3 = 10 % 3;
//	printf("%d\n", ret1);
//	printf("%lf\n", ret2);
//	printf("%lf\n", ret3);
//	return 0;
//}


//移位操作符 << >>--二进制位,操作数只能是整数
//二进制的表示形式
//原码、反码、补码
//正数的原码、反码、补码相同
//原码:按照一个数的正负,直接写出二进制序列
//反码:符号位不变,其他位按位取反
//补码:反码+1
//补码:符号位不变,-1--->取反---->原码
//补码:符号位不变,取反--->+1---->原码
//00000000000000000000000000001010 ---  10的二进制(原码)
//00000000000000000000000000001010 ---  10的二进制(反码)
//00000000000000000000000000001010 ---  10的二进制(补码)

//10000000000000000000000000001010 --- -10的二进制(原码)
//11111111111111111111111111110101 --- -10的二进制(反码)
//11111111111111111111111111110110 --- -10的二进制(补码)

//补码:符号位不变,取反--->+1---->原码
//11111111111111111111111111110110 --- -10的二进制(补码)
//10000000000000000000000000001001(不是补码)
//10000000000000000000000000001010 --- -10的二进制(原码)
//数值:12
//2进制:1100
//8进制:14
//10进制:12
//16进制:c
//内存中存储补码的二进制
//左移操作符 << --- 
//正数:左移一位,结果乘2,原来的数不变,左边丢弃,右边补0
//负数:
//左移操作符 << --- 左移一位,结果乘2,原来的数不变
//右移操作符
//算术右移:右边丢弃,左边补原来的符号位
//逻辑右移:右边丢弃,左边补0
//对于移位运算符,不要移动负数位,这个是标准未定义的。
//#include<stdio.h>
//int main()
//{
//	int a = -10;//4个字节,32个比特位
//	//10000000000000000000000000001010 - 原码
//	//11111111111111111111111111110101
//	//11111111111111111111111111110110 - 补码
//	//内存中存放的是补码
//	int b = a << 1;
//	//11111111111111111111111111101100 - 内存(补码)//右边补0,左边丢掉一位
//	//10000000000000000000000000010011
//	//10000000000000000000000000010100 - 原码
//	int c = -1;
//	//只有-1的补码全是1;
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	int d = c >> 1;
//	printf("b = %d\n", b);
//	printf("%d\n", d);
//	return 0;
//}


//位操作符
//对应的二进制位有0为0,同时为1则为1。
//& --- 按位与
//#include<stdio.h>
//
//int main()
//{
//	int a = 3;
//	//00000000000000000000000000000011
//	int b = -5;
//	//10000000000000000000000000000101
//	//11111111111111111111111111111010
//	//11111111111111111111111111111011(补码)
//	int c = a & b;//a和b的补码
//	//00000000000000000000000000000011
//	//11111111111111111111111111111011(补码)
//	//00000000000000000000000000000011(a&b)
//	printf("%d\n", c);
//	return 0;
//}


//| --- 按位或
//对应的二进制位有1为1,同时为0则为0。
//#include<stdio.h>
//int main()
//{
//	int a = 3;
//	//00000000000000000000000000000011
//	int b = -5;
//	//10000000000000000000000000000101
//	//11111111111111111111111111111010
//	//11111111111111111111111111111011(补码)
//	int c = a | b;//a和b的补码
//	//00000000000000000000000000000011
//	//11111111111111111111111111111011(补码)
//	//11111111111111111111111111111011(补码)
//	//10000000000000000000000000000100
//	//10000000000000000000000000000101(原码)
//	printf("%d\n", c);
//	return 0;
//}


//^ --- 按位异或
//对应的二进制位:相同为0,相异为1
//a^a = 0
//0^a = a
//支持交换律
//#include<stdio.h>
//int main()
//{
//	int a = 3;
//	//00000000000000000000000000000011
//	int b = -5;
//	//10000000000000000000000000000101
//	//11111111111111111111111111111010
//	//11111111111111111111111111111011(补码)
//	int c = a ^ b;//a和b的补码
//	//00000000000000000000000000000011
//	//11111111111111111111111111111011(补码)
//	//11111111111111111111111111111000
//	//10000000000000000000000000000111
//	//10000000000000000000000000001000//原码
//	printf("%d\n", c);
//	return 0;
//}


//赋值操作符
//复合赋值符
//重新赋值
//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	int b = 0;
//	int c = 0;
//	a += 5;
//	return 0;
//}


//单目操作符
//!      逻辑反操作
//C语言中,0表示假,非0表示真
//-      负值
//+	     正值
//&      取地址
//sizeof 操作数的类型长度（以字节为单位）
//~      对一个数的二进制按位取反
//--     前置、后置--
//++     前置、后置++
//*      间接访问操作符(解引用操作符)
//(类型)强制类型转换
//#include<stdio.h>
//int main()
//{
//	int flag = 0;
//	printf("%d\n", flag);
//	printf("%d\n", !flag);
//	return 0;
//}


//布尔类型
//#include<stdbool.h>
//#include<stdio.h>
//int main()
//{
//	_Bool flag = true;
//	if (flag)
//	{
//		printf("hehe\n");
//	}
//}


//-
//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	int b = -10;
//	printf("%d\n", a);
//	printf("%d\n", -a);
//}


//unsigned
//signed
//#include<stdio.h>
//int main()
//{
//	unsigned int a = 10;//二进制的最高位是有效位,不是符号位
//	//00000000000000000000000000001010
//	unsigned int b = -10;
//	//10000000000000000000000000001010
//	//11111111111111111111111111110101
//	//11111111111111111111111111110110
//	printf("%u\n", b);
//}


//&取地址
//取出一个对象内存里的地址
//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	printf("%p\n", &a);
//	int* pa = &a;
//	
//	char* ch = 'w';
//	char* pc = &ch;
//	
//	char* p = "abcdef";
//	printf("%p\n", p);
//	printf("%c\n", *p);
//	return 0;
//}


//*解引用
//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	*pa = 20;
//	printf("%d\n", a);
//}


//sizeof是操作符,不是函数
//#include<stdio.h>
//int main()
//{
//	//int a = 10;
//	//printf("%d\n", sizeof(a));
//	//printf("%d\n", sizeof(int));
//	//int arr[10] = 0;
//	//printf("%d\n", sizeof(arr));
//	//printf("%d\n", sizeof(int[10]));
//	int a = 10;
//	short s = 5;
//	printf("%d\n", sizeof(s = a + 3));//sizeof表达式不计算,由s决定大小
//	printf("%d\n", s);
//	return 0;
//}


//~ 对一个数的二进制按位取反
//二进制的所有位(包括符号位)
//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	//00000000000000000000000000001010//补码
//	//11111111111111111111111111110101//取反
//	//10000000000000000000000000001010//取反
//	//10000000000000000000000000001011//原码
//	printf("%d\n", ~a);
//	return 0;
//}


//练习
//#include<stdio.h>
//int main()
//{
//	int a = 9;
//	//00000000000000000000000000001001
//	//00000000000000000000000000010000
//	//00000000000000000000000000011001
//	//00000000000000000000000000001001
//	//11111111111111111111111111101111
//	a = a | (1 << 4);
//	printf("%d\n", a);
//	a &= (~(1 << 4));
//	printf("%d\n", a);
//	return 0;
//}


//--     前置、后置--
//++     前置、后置++
//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	int b = a++;
//	int c = ++a;
//	printf("%d\n", a);
//	printf("%d\n", b);
//	printf("%d\n", c);
//	return 0;
//}


//++ --带有副作用的,会使得本身发生变化
//#include<stdio.h>
//int main()
//{
//	int a = 10;
//	int b = ++a;
//
//	int c = 10;
//	int d = a + 1;
//	return 0;
//}


//强制类型转换
//#include<stdio.h>
//int main()
//{
//	int a = (int)3.14;
//	printf("%d\n", a);
//	return 0;
//}


//#include <stdio.h>
//void test1(int arr[])//可以写成数组,也可以写成指针
//{
//	printf("arr2 = %zd\n", sizeof(arr));//指针
//}
//void test2(char ch[])
//{
//	printf("ch2 = %zd\n", sizeof(ch));
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("arr1 = %zd\n", sizeof(arr));
//	printf("ch1 = %zd\n", sizeof(ch));
//	test1(arr);
//	test2(ch);
//	return 0;
//}


//#include<stdio.h>
//void test1(int arr[], int sz)
//{
//	int i = 0;
//	for (i = 0;i < sz;i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//}
//void test2(int* arr, int sz)
//{
//	int i = 0;
//	for (i = 0;i < sz;i++)
//	{
//		printf("%d ", arr[i]);
//	}
//}
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	test1(arr, sz);
//	test2(arr, sz);
//}


//关系操作符
//>
//>=
//<
//<=
//!= --- 用于判断"不相等"
//== --- 用于判断"相等"


//逻辑操作符
//&& 逻辑与(并且)
//两个同时为真都是真,有一个为假都是假
//左边为假,右边不计算
//|| 逻辑或(或者)
//两个同时为假都是假,有一个为真都是假
//左边为真,右边不计算
//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	int b = 5;
//	if (a && b)
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	int b = 5;
//	if (a || b)
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}


//短路
//#include <stdio.h>
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;//左边为假,右边不计算
//	//i = ++a && ++b && d++;
//	//i = a++||++b||d++;//左边为真,右边不计算
//	//i = ++a||++b||d++;
//	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
//	return 0;
//}


//条件操作符
//三目操作符
//exp1?exp2:exp3
//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	int b = (a > 5 ? 3 : -3);
//	printf("%d\n", b);
//	return 0;
//}


//逗号表达式
//用逗号隔开的多个表达式
//exp1,exp2,exp3....,expn
//从左向右依次计算,最后一个表达式的值是表达式的结果
//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);
//	printf("%d\n", c);
//	return 0;
//}


//下标引用操作符、函数调用和结构成员
//[] --- 下标引用操作符
//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };//操作数:数组名arr和4
//	return 0;
//}
//() --- 函数调用操作符
//接受一个或者多个操作数
//第一个操作数是函数名,剩余的操作数就是传递给函数的参数
//至少有一个操作数
//#include<stdio.h>
//int main()
//{
//	int len = strlen("abcdef");
//	printf("%d\n", len);
//	return 0;
//}


//.    结构体.成员名
//->   结构体指针->成员名
//内置类型
//自定义类型
//结构体
//枚举
//联合体
//结构体 - 自定义类型(聚合类型)
//#include<stdio.h>
//struct Book
//{
//	char name[20];
//	char author[30];
//	int price;
//};
//void print(struct Book* p)
//{
//	printf("%s %s %d\n", (*p).name, (*p).author, (*p).price);//变量
//	printf("%s %s %d\n", p->name, p->author, p->price);//指针
//}
//int main()
//{
//	struct Book b1 = { "C语言","张三",66 };
//	struct Book b2 = { "C++","李四",88 };
//	printf("%s %s %d\n", b1.name, b1.author, b1.price);
//	printf("%s %s %d\n", b2.name, b2.author, b2.price);
//	print(&b1);
//	return 0;
//}


//#include <stdio.h>
//struct Stu
//{
//	char name[10];
//	int age;
//	char sex[5];
//	double score;
//};
//void set_age1(struct Stu stu)
//{
//	stu.age = 18;
//}
//void set_age2(struct Stu* pStu)
//{
//	pStu->age = 18;//结构成员访问
//}
//int main()
//{
//	struct Stu stu;
//	struct Stu* pStu = &stu;//结构成员访问
//	stu.age = 20;//结构成员访问
//	set_age1(stu);//传值
//	printf("%d\n", stu.age);
//	pStu->age = 20;//结构成员访问
//	set_age2(pStu);//传址
//	printf("%d\n", stu.age);
//	return 0;
//}


//表达式求值
//隐式类型转换
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//为了获得这个精度,表达式中的字符和短整型操作数在使用之前被转换为普通整型
//这种转换称为整型提升
//整型提升的意义:
//表达式的整型运算要在CPU的相应运算器件内执行
//CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度
//同时也是CPU的通用寄存器的长度。
//即使两个char类型的相加,在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
//通用CPU是难以直接实现两个8比特字节直接相加运算
//虽然机器指令中可能有这种字节相加指令
//表达式中各种长度可能小于int长度的整型值,都必须先转换为int或unsigned int
//然后才能送入CPU去执行运算。
//#include<stdio.h>
//int main()
//{
//	char a = 3;
//	//截断
//	//00000000000000000000000000000011
//	//00000011 --- a里放的
//	char b = 123;
//	//00000000000000000000000001111111
//	//01111111
//	//char c = (int)a + (int)b;
//	char c = a + b;
//	//00000011
//	//01111111
//	//整形提升
//	//00000000000000000000000001111111
//	//00000000000000000000000000000011
//	//00000000000000000000000010000010
//	//10000010
//	//%d -- 打印十进制的整数
//	//11111111111111111111111110000010 --- 补码
//	//11111111111111111111111110000001 
//	//10000000000000000000000001111110 --- 原码
//	printf("%d\n", c);
//	return 0;
//}


//char - 有符号char的取值范围:-128-127
//00000000 --- 0
//00000001 --- 1
//00000010 --- 2
//00000011 --- 3
//...
//01111111 --- 127
//10000000(补码) --- -128//规定的
//10000001 --- -127
//...
//11111110 --- -2
//11111111 --- -1
//unsigned char的取值范围:0-255


//#include<stdio.h>
//int main()
//{
//	char a = 0xb6;//8个bit位
//	//10110110
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));
//	printf("%u\n", sizeof(+c));
//	printf("%u\n", sizeof(-c));
//	return 0;
//}


//算术转换
//如果某个操作符的各个操作数属于不同的类型,
//那么除非其中一个操作数的转换为另一个操作数的类型,否则操作就无法进行。
//如果某个操作数的类型在上面这个列表中排名较低
//那么首先要转换为另外一个操作数的类型后执行运算向上转换
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int


//复杂表达式的求值有三个影响的因素:
//1.操作符的优先级
//2.操作符的结合性
//3.是否控制求值顺序。
//两个相邻的操作符先执行取决于他们的优先级。
//如果两者的优先级相同,取决于他们的结合性。
//#include<stdio.h>
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = 4;
//	int d = a * 4 + b / 3 + c;
//	return 0;
//}


